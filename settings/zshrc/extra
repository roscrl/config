setopt   AUTO_CD          # cd by typing directory name if it's not a command
setopt   AUTO_MENU        # show completion menu automatically
setopt   COMPLETE_IN_WORD # allow completion from within words
setopt   ALWAYS_TO_END    # move cursor to end of word on completion
setopt   AUTO_PUSHD       # automatically push directories onto the stack
unsetopt CORRECT_ALL      # disable command correction
unsetopt FLOWCONTROL      # disable ^S/^Q flow control

zstyle ':completion:*' matcher-list 'm:{a-z}={A-Za-z}' # built in zsh autocomplete will match lowercase to uppercase

# git branch on the right when in git folder https://scriptingosx.com/2019/07/moving-to-zsh-06-customizing-the-zsh-prompt/
PROMPT='%B%F{blue}%2~%f%b %# '
autoload -Uz vcs_info
precmd_vcs_info() { vcs_info }
precmd_functions+=( precmd_vcs_info )
setopt prompt_subst
RPROMPT=\$vcs_info_msg_0_
zstyle ':vcs_info:git:*' formats '%F{240}%b%f'
zstyle ':vcs_info:*' enable git

function mkcd() { mkdir $1 && cd $1; }
function cnw() { open -na "Google Chrome" --args --new-window "$@" }
function killport() { lsof -i tcp:$1 | awk 'NR!=1 {print $2}' | xargs kill -9 }
function myip() { curl -s https://api.ipify.org; printf "\n" }
function grab() { find . -type f -print0 | while IFS= read -r -d \'\' file; do echo "$file\`\`\`"; cat "$file"; echo "\`\`\`"; done | pbcopy }
function rs() { bundle exec foreman start -f Procfile.dev "$@" }
function speedcheck() { for i in $(seq 0 50); do /usr/bin/time -p /bin/zsh -i -c exit 2>&1 | grep real | awk '{print $2}'; done | awk '{ sum += $1 } END { print "Average time:", sum/NR, "seconds" }' }; # 0.01462 seconds avg

function initialize_gh_copilot_alias() {
    if ! alias | grep -q "alias ghcs="; then
        eval "$(gh copilot alias -- zsh)"
    fi
}

function clone_cd_vim() {
  local url="$1"; 
  local dir_name=$(basename "$url" .git); 

  if [[ $url =~ ^(https|git|ssh)://.+\.git$ || $url =~ ^git@.+:.+\.git$ ]]; then 
      git clone "$url" && cd "$dir_name" && vim .; 
  else 
      echo "Invalid Git URL"; 
  fi 
}

function clone_cd() {
  local url="$1"; 
  local dir_name=$(basename "$url" .git); 

  if [[ $url =~ ^(https|git|ssh)://.+\.git$ || $url =~ ^git@.+:.+\.git$ ]]; then 
      git clone "$url" && cd "$dir_name";
  else 
      echo "Invalid Git URL"; 
  fi 
}

function fcd() {
  local dir;
  while true; do
    # exit with ^D
    dir="$(ls -a1F | grep '[/@]$' | grep -v '^./$' | sed 's/@$//' | fzf --height 40% --reverse --no-multi --preview 'pwd' --preview-window=up,1,border-none --no-info)"
    if [[ -z "''${dir}" ]]; then
      break
    elif [[ -d "''${dir}" ]]; then
      cd "''${dir}"
    fi
  done
}

function pbfilter() {
    if [ $# -gt 0 ]; then
        pbpaste | "$@" | pbcopy
    else
        pbpaste | pbcopy
    fi
}  

function open_github() {
  local remote_url=$(git config --get remote.origin.url)
  if [[ -z "$remote_url" ]]; then
    echo "Not a git repository or no remote.origin.url set"
    return 1
  fi

  # Convert SSH URL to HTTPS if necessary
  if [[ $remote_url == git@github.com:* ]]; then
    remote_url=''${remote_url/git@github.com:/https://github.com/}
  fi

  # Remove .git suffix if present
  remote_url=''${remote_url%.git}

  # Open the URL in the default browser
  if [[ "$OSTYPE" == "darwin"* ]]; then
    open "$remote_url"
  elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
    xdg-open "$remote_url"
  else
    echo "Unsupported operating system"
    return 1
  fi
}

# Function to initialize a Nix flake development environment with direnv
# Usage: denv <pkg1> <pkg2> ...
function denv() {
  # Check if any arguments (package names) were provided
  if [[ $# -eq 0 ]]; then
    print -u2 "Error: No packages specified."
    print -u2 "Usage: denv <pkg1> <pkg2> ..."
    return 1
  fi

  local envrc_file=".envrc"
  local flake_file="flake.nix"
  local gitignore_file=".gitignore"
  local gitignore_entries=(".DS_Store" ".direnv/") # Array of entries to ensure

  # --- Check and create .envrc ---
  if [[ -e "$envrc_file" ]]; then
    print -u2 "Error: '$envrc_file' already exists. Aborting."
    return 1
  else
    echo "use flake" > "$envrc_file"
    # Optionally allow direnv if installed
    if command -v direnv &> /dev/null; then
        print "Running 'direnv allow .'..."
        direnv allow .
    else
        print "Warning: direnv command not found. You may need to run 'direnv allow .' manually."
    fi
  fi

  # --- Check and create flake.nix ---
  if [[ -e "$flake_file" ]]; then
    print -u2 "Error: '$flake_file' already exists. Aborting."
    return 1
  fi

  # --- Prepare package list for flake.nix ---
  # This part remains the same, formatting the packages correctly.
  local pkgs_string=""
  local num_pkgs=$#
  local current_pkg_num=0

  for pkg in "$@"; do
    ((current_pkg_num++))
    # Indentation needs to match the 'packages' list in the new template (14 spaces)
    pkgs_string+="          ${pkg}"
    # Add a newline unless it's the very last package
    if [[ $current_pkg_num -lt $num_pkgs ]]; then
      pkgs_string+="\n"
    fi
  done

  # --- Create flake.nix using the forAllSystems template ---
  cat <<EOF > "$flake_file"
{
  inputs = {
    nixpkgs.url = "github:nixos/nixpkgs/nixos-unstable";
  };

  outputs = { self, nixpkgs, ... }:
  let
    forAllSystems = f: nixpkgs.lib.genAttrs [ "x86_64-linux" "aarch64-linux" "x86_64-darwin" "aarch64-darwin" ] (system: f nixpkgs.legacyPackages.\${system});
  in {
    devShells = forAllSystems (pkgs: {
      default = pkgs.mkShell {
        packages = with pkgs; [
${pkgs_string}
        ];
      };
    });
  };
}
EOF

  if [[ -f "$gitignore_file" ]]; then
    # File exists, check and append missing entries
    local entry_added=false
    for entry in "${gitignore_entries[@]}"; do
      # Use grep -qxF to check for exact, full line match, suppressing output
      if ! grep -qxF "$entry" "$gitignore_file"; then
        print "  Adding '$entry' to $gitignore_file"
        # Append the entry on a new line
        echo "$entry" >> "$gitignore_file"
        entry_added=true
      fi
    done
  else
    # Use printf for reliable newline handling
    printf '%s\n' "${gitignore_entries[@]}" > "$gitignore_file"
  fi

  return 0
}
